## 锁相关   
- 死锁        
    - 定义：一个进程集合中的每个进程都在等待只能由此集合中的其他进程才能引发的事件，  
        而陷入无限僵持的局面。  
    - 死锁产生条件：  
        - 互斥条件：临界资源是独占资源     
        - 占有和等待条件：进程请求资源时不释放已占有资源    
        - 不剥夺条件：资源只能由进程自愿释放       
        - 循环等待条件：每个进程都在等待下一个进程所持有的资源     

    - 死锁避免    
        - 银行家算法
            - 当一个顾客对资金的最大需求量不超过银行家现有的资金时就可接纳该顾客;
            - 顾客可以分期贷款,但贷款的总数不能超过最大需求量;
            - 当银行家现有的资金不能满足顾客尚需的贷款数额时,对顾客的贷款可推迟支付,但总能使顾客在有限的时间里得到贷款;
            - 当顾客得到所需的全部资金后,一定能在有限的时间里归还所有的资金.
            - 结构：
                - 可利用资源向量Available : m个元素的数组
                - 最大需求矩阵Max ： n×m的矩阵
                - 分配矩阵Allocation ：n×m的矩阵
                - 需求矩阵Need ： n×m的矩阵，表示每一个进程尚需的各类资源数。
    - 解除死锁        
        - 剥夺资源      
        - 撤销进程       


- 互斥锁：保证了使用资源线程的唯一性和排他性，但是无法限制资源释放后其他线程申请的顺序问题；    
        互斥锁必须由单个线程获取和释放
- 信号量：保证了线程执行的有序性；由单个线程释放，另一个线程获取，保证线程同步  
- 自旋锁：当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，    
        然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。  

-------

- 悲观锁：在修改数据之前把数据锁住，然后再对数据进行读写，在它释放锁之前任何人都不能对其数据进行操作。
    - 特点：保证数据的独占性和正确性；加锁释放锁的过程会造成消耗，性能不高。
- 乐观锁：操作数据时不会对操作的数据进行加锁，只有到数据提交的时候才通过一种机制来验证数据是否存在冲突。
    - 特点：一种并发类型的锁，其本身不对数据进行加锁通而是通过业务实现锁的功能；性能高。 

## 进程、线程
- 孤儿进程: 一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。  
- 僵尸进程: 如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，    
            那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。        
- 僵尸进程的避免
    - 让僵尸进程的父进程来回收，父进程每隔一段时间来查询子进程是否结束并回收，调用wait()或者waitpid(),通知内核释放僵尸进程  
    - 采用信号SIGCHLD通知处理，并在信号处理程序中调用wait函数（子进程死后，会发送SIGCHLD信号给父进程）      
    - 让僵尸进程变成孤儿进程，由init回收，就是让父亲先死（fork 两次，父进程fork子进程后继续执行，子进程fork一个孙进程后退出）   
- wait()调用不能确切等待某一个子进程结束
- 进程：
    - 阻塞 ——> 就绪 <——> 运行 ——> 阻塞
- 线程：
    - 同上，增加： 新建 ——> 就绪、运行 ——> 死亡  

进程与线程、协程    
进程是资源分配的基本单位。      
线程是独立调度的基本单位。      
一个进程中可以有多个线程，它们共享进程资源。    

- 需要频繁创建销毁的优先用线程（进程的创建和销毁开销过大）
- 需要进行大量计算的优先使用线程（CPU频繁切换）

区别
Ⅰ 拥有资源
进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。

Ⅱ 调度
线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，
从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。

Ⅲ 系统开销
由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，
所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当
前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保
存和设置少量寄存器内容，开销很小。

Ⅳ 通信方面
线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。  
不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行      

协程：  
+ 协程的特点在于是一个线程执行  
+ 拥有极高的执行效率，协程切换由程序自身控制（也就是在用户态执行），没有线程切换的开销。      
+ 不需要多线程的锁机制
+ 执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行 


进程切换分3步:

1. 切换页目录以使用新的地址空间
2. 切换内核栈
3. 切换硬件上下文

而线程切换只需要第2、3步,因此进程的切换代价比较大


进程通信
1. 管道
 - 只支持半双工通信（单向交替传输）；  
 - 只能在父子进程中使用。  

2. FIFO 命名管道
 - 去除了管道只能在父子进程中使用的限制

3. 消息队列
 - 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；
 - 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；
 - 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。
        
 - 消息队列实现
    - 是一个消息的链表。
    - 有写权限的进程可以向消息队列中添加新消息；有读权限的进程则可以从消息队列中读走消息。
    - 消息本质上是一种数据结构
        
4. 信号量: 一个计数器，用于为多个进程提供对共享数据对象的访问。    

5. 共享存储
        允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。
        需要使用信号量用来同步对共享存储的访问。
        多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。
        另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。

6. 套接字: 可用于不同机器间的进程通信。


## 线程安全
- 含义
    - 就是多线程访问时，采用加锁机制，当一个线程访问该类的某个数据时，进行保护
    - 其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。
- 线程安全问题都是由全局变量及静态变量引起的
- 有多个线程同时执行写操作，需要考虑线程同步，否则的话就可能影响线程安全。


## 线程同步
- 互斥锁
    > 本质就是一个特殊的全局变量，拥有lock和unlock两种状态，unlock的互斥锁可以由某个线程获得，
    一旦获得，这个互斥锁会锁上变成lock状态，此后只有该线程由权力打开该锁，只允许一个线程进入临界区。
    - 初始化锁: pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutex_attr_t *mutexattr)
        - mutexattr 有四个值可选，缺省为普通锁，分别代表
            - 普通锁：
                - 当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后按优先级获得锁。
                - 这种锁策略保证了资源分配的公平性。
            - 嵌套锁
                - 允许同一个线程对同一个锁成功获得多次，并通过多次unlock解锁。
                - 如果是不同线程请求，则在加锁线程解锁时重新竞争。
            - 检错锁
                - 如果同一个线程请求同一个锁，则返回 EDEADLK，否则与普通锁类型动作相同
                - 保证当不允许多次加锁时不会出现最简单情况下的死锁。
            - 适应锁
                - 动作最简单的锁类型，仅等待解锁后重新竞争
    - 阻塞加锁：pthread_mutex_lock()
    - 非阻塞加锁: pthread_mutex_trylock()
    - 解锁（要求锁是lock状态,并且由加锁线程解锁）:pthread_mutex_unlock()
    - 销毁锁（此时锁必需unlock状态,否则返回EBUSY）: pthread_mutex_destroy()
- 条件变量：利用线程间共享全局变量进行同步的一种机制。
    > 当线程在等待满足某些条件时使线程进入睡眠状态，一旦条件满足，就唤醒因等待满足特定条件而睡眠的线程
    - 初始化条件变量： pthread_cond_init()
    - 两个等待函数
        - 无条件等待: pthread_cond_wait()
        - 计时等待: pthread_cond_timewait(), 如果在给定时刻前条件没有满足，则返回 ETIMEDOUT
    - 激发条件
        - 激活一个等待该条件的线程（存在多个等待线程时按入队顺序激活其中一个）: pthread_cond_signal()
        - 激活所有等待线程: pthread_cond_broadcast()
    - 销毁条件变量: pthread_cond_destroy
        - 只有在没有线程在该条件变量上等待的时候才能销毁这个条件变量，否则返回EBUSY
- 读写锁：可以多个线程同时读，但是不能多个线程同时写。锁处于读模式时可以线程共享，而锁处于写模式时只能独占。
    - 适用于读多写少场景
- 信号量：允许多个线程进入临界区
    - 有四个相关函数
        - 信号量初始化：sem_init()
        - 等待信号量: sem_wait(), 给信号量减1，然后等待直到信号量的值大于0。
        - 释放信号量: sem_post(), 信号量值加1。并通知其他等待线程。
        - 销毁信号量: sem_destroy(), 用完信号量后都它进行清理。归还占有的一切资源。


- 软链接、硬链接
    - 文件
        - 用户数据：文件数据块，数据块是记录文件真实内容的地方。
        - 元数据：文件的附加属性，如文件大小、创建时间、所有者等信息。
            - 元数据中的inode号是文件的唯一标识而非文件名
            - 系统或程序通过inode号寻找正确的文件数据块
            - 查看inode号可使用命令stat或ls -i
    - 硬链接：一个inode号对应多个文件名（有着相同inode号仅文件名不同的文件）
        - 文件有相同的inode以及data block
        - 只能对已存在的文件进行创建
        - 不能交叉文件系统（不能跨越文件系统）进行硬链接的创建
        - 不能对目录进行创建，只可对文件创建
        - 删除一个硬链接文件并不影响其他有相同inode号的文件
    - 软链接：有着自己的inode号以及用户数据块
        - 软链接有自己的文件属性及权限等；
        - 可对不存在的文件或目录创建软链接；
        - 软链接可交叉文件系统；
        - 软链接可对文件或目录创建；
        - 创建软链接时，链接计数i_nlink不会增加；
        - 删除软链接并不影响被指向的文件，但若指向的原文件被删除，则相关软链接被称为死链接(即dangling link）


\ | 原码|补码|反码
:-:|:-:|:-:|:-:
+7|0000 0111|0000 0111|0000 0111    
-7|1000 0111|1111 1001|1111 1000    

+ 正数的原码补码反码一致  
+ 负数的反码：符号位不变，数值位按位取反
+ 负数的补码：反码+1

~a == -a-1  

虚拟：
+ 时分复用：多个进程能在同一个处理器上并发执行
+ 空分复用：虚拟内存

1. 查看kafka对应的进程号 

ps -ef | grep kafka 

2. 查看端口对应的进程号 、查看某个端口是否被占用
    - netstat  -anp  |grep   端口号
    -  lsof –i: 端口号

3. 根据进程号查看对应的信息，比如端口啥的    

netstat -anop | grep PID

4. 显示前20行中的后10行 

head -n 20 /etc/passwd |tail -n 10 

**sort:对文件进行排序**  
example:    
sort -k 2 -t '.' test.txt       
解释： 根据符号“.”分割字符串，并以分割后的test.txt 文件中的第2列进行排序。         

- chown : 将指定文件的拥有者改为指定的用户或组
- chmod : 改权限  

将档案 file1.txt 设为所有人皆可读取 :   
chmod ugo+r file1.txt   
or  
chmod a+r file1.txt     

查找当前目录下文件名包含字符串string的文件  
find . -name '*string*' 

linux查看资源的命令?怎么样查看哪些端口被占用了
- top
- uptime：查看系统负载
- du: 显示目录或者文件所占空间(默认单位kb)
- df: 查看文件系统的整体磁盘空间使用情况(默认单位kb)


怎么让linux内一个文件的大小变为二倍 
- cat 、追加>> 

Linux三剑客： sed、grep、awk
    
- 大端：高地址放低位， 低地址放高位
- 小端：高地址放高位， 低地址放低位

    - eg：0x1234
    - 大端：内存中 12 34 
    - 小端：内存中 34 12 

    
 kill kill -9     
    - kill: 向进程号为pid的进程发送SIGTERM,该信号是一个结束进程的信号且可以被应用程序捕获。 
            若应用程序没有捕获并响应该信号的逻辑代码，则该信号的默认动作是kill掉进程。      
    - kill -9:  
        - 向进程号为pid的进程发送SIGKILL,   
        - SIGKILL既不能被应用程序捕获，也不能被阻塞或忽略，其动作是立即结束指定进程。   
        - SIGKILL信号是直接发给init进程的，它收到该信号后，负责终止pid指定的进程。  
        - 在这种“暴力”情况下，应用程序完全没有释放当前占用资源的机会。  

- SIGINT：CTRL + c
- SIGKILL：kill -9
- SIGTERM：kill
- SIGTSTP：CTRL + z
- SIGHUP：系统对SIGHUP信号的默认处理是终止收到该信号的进程；对于与终端脱离关系的守护进程，这个信号用于通知它重新读取配置文件
- 编译阶段都干了啥
    - 预处理：
    - 编译 ：语法和语义分析，然后生成中间代码，此中间代码是汇编代码。
    - 汇编：将汇编代码翻译成机器码指令
    - 链接：完成文件中调用的各种函数跟静态库和动态库的链接，并将它们一起打包合并形成目标文件（可执行文件）。

中断信号处理函数必须是可重入的  
可重入函数可以认为是线程安全的函数，也就是即使多个线程乱序调用某一个函数，依然能够得到预期的结果    
使用不可重入的函数可能会导致进程执行混乱，甚至是陷入到休眠状态，失去进程的控制  
诸如 printf()、malloc()等函数都是不可重入的 

## 生产者-消费者模式实现
- 生产者和消费者在同一时间段内共用同一存储空间，生产者向空间里生产数据，而消费者取走数据。 
```Python
from threading import Thread
from queue import Queue
import time

class Produce(Thread):
    num=0
    def run(self):
        while True:       # 轮询 不停的做if 判断 
            if queue.qsize()<1000:   # 判断 queue 的容量 ，如果小于 就开始生产
                for i in range(10):
                    queue.put("我生产了序号为%d"%(self.num))   # 循环十次  ，并在queue 容器里追加
                    self.num += 1
                    print("我生产了序号为%d"%(self.num))
            time.sleep(3)
class Consume(Thread):

    def run(self):
        while True:
            if queue.qsize()>100:  #判断 queue 的容量 ，如果大于 就开始消费
                for i in range(3):
                    msg="我消费了序号为%d"%i+ queue.get()  #循环三次 并不停的去除 queue 的值
                    print(msg)
            time.sleep(3)
if __name__=="__main__":
    queue=Queue()
    for i in range(500):
        queue.put("这是我初始化的东西，序号为%d"%i)  # 初始化数据
    for i in range(2):
        p1=Produce()
        p1.start()
    for i in range(5):
        p2=Consume()
        p2.start()

```