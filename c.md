strlen()与sizeof()辨析  
strlen():计算字符串的长度，不包括结束字符 
sizeof():计算所数据所占空间，包括结束字符 

单精度：7 位有效位数    
双精度：16 位有效位数   

eg:   
char sArr[] = "ILOVEC"  
strlen(sArr) == 6	//有6个字符 
sizeof(sArr) == 7	//占7字节   


while(p)  == whlie(p != NULL)

while(*p)  == while(*p != 0)

除法运算：  
首先先说余数，在C语言中余数的符号是和被除数的符号相同。即： 
      (-10)%3==-1;  
      10%(-3)==1;   
      (-10)%(-3)==-1;   
做除法的时候，商是令其与分子相乘的积的绝对值不超过分母的绝对值且最接近的那个数，    
所以
      (-10)/3==-3;  
      10/(-3)==-3;  
      (-10)/(-3)==3;          

数组：数组是用于储存多个相同类型数据的集合。    
指针：指针相当于一个变量，但是它和普通变量不一样，它存放的是其它变量在内存中的地址。  
区别：      
- 同类型指针变量可以相互赋值，数组不行，只能一个一个元素的赋值或拷贝。
- 数组在内存中是连续存放的，开辟一块连续的内存空间。
- 指针很灵活，它可以指向任意类型的数据。指针的类型说明了它所指向地址空间的内存。  
- 数组传参时，会退化为指针。  
      1. 退化的意义：C语言只会以值拷贝的方式传递参数，参数传递时，如果只拷贝整个数组，效率会大大降低，并且在参数位于栈上，太大的数组拷贝将会导致栈溢出。     
      2. 因此，C语言将数组的传参进行了退化。将整个数组拷贝一份传入函数时，将数组名看做常量指针，传数组首元素的地址
- 访问：数组是随机访问，指针顺序访问
- 增加：数组如果要在某个节点前插入节点，此节点后的所有节点要后移一个空间
- 删除：同增加    


指针和引用: 
相同点：

- 都是地址的概念；指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名。  

不同点：

- 指针是一个实体，而引用仅是个别名；
- 指针可以为空，引用不能为空  
- 引用只能在定义时被初始化一次，之后不可变；指针可变；引用“从一而终”，指针可以“见异思迁”；
- 引用没有const，指针有const，const的指针不可变；（具体指没有int& const a这种形式，而const int& a是有 的， 
      前者指引用本身即别名不可以改变，这是当然的，所以不需要这种形式，后者指引用所指的值不可以改变）
- 引用不能为空，指针可以为空；
- sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小；
- 指针和引用的自增(++)运算意义不一样；引用是值++，指针是移动到下一块内存
- 引用是类型安全的，而指针不是 (引用比指针多了类型检查)




## fork     
- 调用一次，返回两次  
- 两个进程执行没有固定的先后顺序，哪个进程先执行要看系统的进程调度策略。  
- 子进程返回 0    
- 父进程返回子进程PID  
- 出错，返回负值             
      - fork出错可能有两种原因：    
      - 当前的进程数已经达到了系统规定的上限，这时errno的值被设置为EAGAIN。   
      - 系统内存不足，这时errno的值被设置为ENOMEM。   
- N次循环创建的子进程数为1+2+4+……+2^(N-1)个     

- C++多态性是通过虚函数来实现的，虚函数允许子类重新定义成员函数。   
- 封装可以使得代码模块化，继承可以扩展已存在的代码，他们的目的都是为了代码重用。而多态的目的则是为了接口重用。
      也就是说，不论传递过来的究竟是那个类的对象，函数都能够通过同一个接口调用到适应各自对象的实现方法。          

## static
- static 变量在程序装载的时候就被初始化，它存在于程序内存空间的
      静态储存区中而不是堆栈中，这样在下一次被调用的时候它还是保持原来的值    
- 和全局变量不一样，它只在自己的作用范围内可见，但是在可用范围之外它并不会消失
- 它和全局变量最大的不同之处，在于它具有隐藏的功能


## 重写
- 参数列表必须完全与被重写的方法相同，否则不能称其为重写而是重载。
- 返回的类型必须一直与被重写的方法的返回类型相同，否则不能称其为重写而是重载。
- 访问修饰符的限制一定要大于被重写方法的访问修饰符（public>protected>default>private）
- 重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常

## 重载
- 必须具有不同的参数列表；
- 可以有不同的返回类型，只要参数列表不同就可以了；
- 可以有不同的访问修饰符
- 可以抛出不同的异常；
- 重载Overloading是一个类中多态性的一种表现。